# Описания и контексты ошибок содержат символ перевода строки, поэтому по нему нельзя определить, где заканчивается одна запись и начинается другая. Однако в начале каждой записи есть время события; заменим его на маркер <NL> (New Line).
#
cat rphost_*/*.log | 
sed -r 's/[0-9]+:[0-9]+.[0-9]+-/<NL>/' | 

# Теперь можно расклеить текст по этому маркеру и собрать статистику по ошибками. В качестве разделителя для утилиты gawk используем вводную конструкцию параметра Descr — сразу после неё платформа выводит описание ошибки, которое нам и нужно.
#
gawk -F'Descr=' -vRS='<NL>' '{if ($2!~/^$/) errors[$2]+=1}END{for (i in errors) print "<NL>" errors[i] " " i}' | 

# Уборка по избежание разных проблем: заменяем пробельные символы на пробелы, удаляем пустые строки.
#
sed -r 's/\s/ /g' | 
sed -r /^$/d | 

# Ошибки нужно отсортировать по частотности. Для этого подходит утилита sort, но сперва нужно добиться того, чтобы в начале каждой строки с ошибкой стояло количество ее воспроизведений. Просто заменить <NL> на переводы строк нельзя, так как описания ошибок по-прежнему содержат переводы строк. Поэтому сначала заменяем переводы строк в описаниях на маркер @; получится что-то вроде:
#
# <NL>1 error1@something1<NL>8 error2@something2<NL>4 error3@something3
#
tr '\n' '@' | 

# Теперь можно заменить <NL> на переводы строк, получив примерно такую картину:
#
# 1 error1@something1
# 8 error2@something2
# 4 error3@something3
#
sed -r 's/<NL>/\n/g' | 

# Сортируем, берем первую тысячу результатов и выводим. Перед выводом заменяем @ обратно на символ перевода строки. Получится так:
#
# 8 error2
# something2
# 4 error3
# something3
# 1 error1
# something1
#
sort -rnb | 
head -n 1000 | 
sed -r 's/@/\n/g' > ExceptionsTop.txt